IS1 : single-node lookup + node property retrieval
Profile of a person : 
Given a start Person with ID $personId, retrieve their first name, last name, birthday, 
IP address, browser, and city of residence.

#Cypher 
MATCH (p1:Person)-[e:IS_LOCATED_IN]->(p2:Place)
WHERE  p1.id=7375
RETURN p1.firstName,  p1.lastName, p1.birthday,p1.locationIP, p1.browserUsed ,p2.name

#cozoscript 
?[fn, ln, br,ip,brw,city_name] := n=7375, *node_label[n, "person"], *node_prop[n, "firstName", fn], *node_prop[n, "lastName", ln], *node_prop[n, "locationIP", ip], *node_prop[n, "birthday", br], *node_prop[n, "browserUsed", brw],  *edge_label[e, "isLocatedIn"], *edge[e,n,n2],*node_label[n2, l], l = "place", *node_prop[n2, "name", city_name]

IS2 : multiple  edge join (comment -hasCreator-person , comment -replyOf-Post, Post-hascreator-original Poster) + filtering + sorting (by date) + limit (TOP 10).
Recent messages of a person
Given a start Person with ID$personId, retrieve the last 10 Messages
created by that user. Foreach Message, return that Message, 
the original Post in its conversation(post), and the author of that Post (original Poster). 
If  any of the Messages is a Post, then the original Post(post)
will be the same Message, i.e.that Message will appear twice in that result.

#cozo correct version

#récupérer les 10 messages récents du user
recent_msgs[msg_id, msg_date] :=
    person_id = 1129,
    *edge[e1, msg_id, person_id], 
    *edge_label[e1, "hasCreator"],
    *node_label[msg_id, lbl],
    (lbl == "post" or lbl == "comment"),
    *node_prop[msg_id, "creationDate", msg_date],
    :order -msg_date
    :limit 10
#remonter la chaîne replyOf jusqu’au Post final
# Base case : un commentaire qui répond directement à un Post
orig_post[c, p] :=
    *node_label[c, "comment"],
    *edge[e, c, p],
    *edge_label[e, "replyOf"],
    *node_label[p, "post"]

# Recursive case : Comment --> Comment --> ... ---> Post
orig_post[c, p] :=
    *node_label[c, "comment"],
    *edge[e, c, c2],
    *edge_label[e, "replyOf"],
    *node_label[c2, "comment"],
    orig_post[c2, p]
cas des Posts (trivial)
msg_post[msg_id, post_id] :=
    recent_msgs[msg_id, _],
    *node_label[msg_id, "post"],
    post_id = msg_id

# cas des commentaires (utilise orig_post)
msg_post[msg_id, post_id] :=
    recent_msgs[msg_id, _],
    *node_label[msg_id, "comment"],
    orig_post[msg_id, post_id]
#final queryy
?[msg_id, msg_date, post_id, orig_poster_id] := recent_msgs[msg_id, msg_date],
    msg_post[msg_id, post_id],
    *edge[e3, post_id, orig_poster_id],
    *edge_label[e3, "hasCreator"]





#cozo first version

recent_msgs[msg_id, msg_date] := person_id =1129, *edge[e1, msg_id, person_id], *edge_label[e1, "hasCreator"], *node_label[msg_id, lbl], (lbl == "post" or  lbl == "comment"), *node_prop[msg_id, "creationDate", msg_date], :order  -msg_date  :limit 10

recent_with_post[msg_id, msg_date, post_id, orig_poster_id] := recent_msgs[msg_id, msg_date], *edge[e2, msg_id, post_id], *edge_label[e2, "replyOf"], *node_label[post_id, "post"], *edge[e3, post_id, orig_poster_id], *edge_label[e3, "hasCreator"]

recent_with_post[msg_id, msg_date, msg_id, orig_poster_id] := recent_msgs[msg_id, msg_date], *node_label[msg_id, "post"], *edge[e3, msg_id, orig_poster_id], *edge_label[e3, "hasCreator"]

?[msg_id, msg_date, post_id, orig_poster_id] := recent_with_post[msg_id, msg_date, post_id, orig_poster_id] 

#Cypher
// recent messages (Post or Comment) created by a given Person 1129
MATCH (p:Person {id: 1129})<-[:HAS_CREATOR]-(m)
WHERE m:Post OR m:Comment
WITH m, p
ORDER BY m.creationDate DESC
LIMIT 10

// for each message, find the original Post and its author
OPTIONAL MATCH (m)-[:REPLY_OF*0..]->(origPost:Post)-[:HAS_CREATOR]->(origPoster:Person)
WITH 
  m AS message,
  coalesce(origPost, m) AS post,    // if m is a Post càd m doesnt have a REPLY_OF et donc  origPost is NULL so coalesce returns the first arg non-NULL which is m
  coalesce(origPoster, p) AS origPoster // same here
RETURN 
  message.id AS messageId,
  message.creationDate AS messageDate,
  post.id AS postId,
  origPoster.id AS originalPosterId
ORDER BY messageDate DESC
LIMIT 10;


IS3 :  multi edge traversal (Person–[:KNOWS]–Person) + edge property retrieval .
Friends of a Person
Given a start person with ID $personId, retrieve all of their friends and the date at which they became friends.

#cozo 
?[friend_id, since] :=
    p1 == 94
    *edge[e, p1, friend_id],
    *edge_label[e, "knows"],
    *edge_prop[e, "creationDate", since],
    

#Cypher

MATCH (p:Person {id: 94})-[r:KNOWS]->(friend:Person)
RETURN friend.id AS friendId, r.creationDate AS since


IS4 : single-node lookup + node property retrieval
Content of a message 
Given a message with ID $messageId, retrieve its content and creation date.
#cozo 
#for sf01 use 618475290625
#for sf1, 03 use 2061584302087
?[content, creation_date] :=
    m=618475290625,
    *node_prop[m, "content", content],
    *node_prop[m, "creationDate", creation_date]

#Cypher
MATCH (m)
WHERE m.id = 618475290625
RETURN m.content AS content, m.creationDate AS creationDate

IS5 : edge traversal (Message -hasCreator - author) + node property retrieval (id).
Creator of a message
Given a Message with ID$messageId, retrieve its author.
# 618475290625 sf01 03
# 2061584302087 sf1
#cozo
?[author_id] :=
    m=2061584302087,
    *edge[eid, m, author_id],
    *edge_label[eid, "hasCreator"]

#Cypher

MATCH (m)-[:HAS_CREATOR]->(a:Person)
WHERE  m.id = 618475290625
RETURN a.id AS authorId

IS6 : conditional edge traversal (post -> Forum or comment -> Post -> Forum) + conditional edge 
join (post -> Forum -> Moderator or comment -> Post -> Forum -> Moderator).
Forum of a message
Given a message with ID $messageId, retrieve the forum that contains it and the person who 
moderates that forum.
Since comments are not directly contained in forums, for comments, return the forum 
containing the original post in the thread to which the comment is replying.
#618475290625 sf01 03
#1236950581250 sf1
#cozo
# --- CASE 1: message is a post ---
forum_of_message[msg_id, forum_id, mod_id] :=
    msg_id=1236950581250,
    *node_label[msg_id, "post"],
    *edge[e1, forum_id, msg_id],
    *edge_label[e1, "containerOf"],
    *edge[e2, forum_id, mod_id],
    *edge_label[e2, "hasModerator"]

# --- CASE 2: message is a comment (replyOf -> post) ---
forum_of_message[msg_id, forum_id, mod_id] :=
    msg_id=1236950581250,
    *node_label[msg_id, "comment"],
    *edge[e1, msg_id, post_id],
    *edge_label[e1, "replyOf"],
    *node_label[post_id, "post"],        
    *edge[e2, forum_id, post_id],
    *edge_label[e2, "containerOf"],
    *edge[e3, forum_id, mod_id],
    *edge_label[e3, "hasModerator"]

# --- Final output ---
?[forum_id, mod_id] :=
    msg_id=1236950581250,
    forum_of_message[msg_id, forum_id, mod_id]

#Cypher

MATCH (m)
WHERE m.id = 1236950581250

OPTIONAL MATCH (m:Post)<-[:CONTAINER_OF]-(f:Forum)-[:HAS_MODERATOR]->(mod:Person)
OPTIONAL MATCH (m:Comment)-[:REPLY_OF]->(p:Post)<-[:CONTAINER_OF]-(f2:Forum)-[:HAS_MODERATOR]->(mod2:Person)

RETURN 
    coalesce(f, f2) AS forum,
    coalesce(mod, mod2) AS moderator


IS7 : edge traversal (comment -> Comment /comment -> Post ) to find destination node, 
multiple  edge join (comment–[:hasCreator]->replyAuthor –[:KNOWS]–originalAuthor )+ boolean computation.
Replies of a message
Given a message with ID $messageId, retrieve the (1-hop) comments that reply to it.
In addition, return a boolean flag knows indicating whether the author of the reply 
(replyAuthor) knows the author of the original message (messageAuthor).
If the author is the same as the originalAuthor, return False for the knows flag.

#COZO 
#for sf01 1030792151049
#for sf03 et sf1  2061584302089
# bidirectional knows relation
knows_pair[p1, p2] :=
    *edge[e, p1, p2], *edge_label[e, "knows"]
knows_pair[p1, p2] :=
    *edge[e, p2, p1], *edge_label[e, "knows"]

#  replies info + knows boolean
replies[reply_id, replyAuthor, messageAuthor, knows_flag] :=
    *edge[e1, reply_id, msg_id],
    *edge_label[e1, "replyOf"],
    msg_id == 2061584302089,
    *node_label[reply_id, "comment"],

    *edge[e2, reply_id, replyAuthor],
    *edge_label[e2, "hasCreator"],
    *edge[e3, msg_id, messageAuthor],
    *edge_label[e3, "hasCreator"],

    # same author = false
    (replyAuthor == messageAuthor),
    knows_flag = false

replies[reply_id, replyAuthor, messageAuthor, knows_flag] :=
    *edge[e1, reply_id, msg_id],
    *edge_label[e1, "replyOf"],
    msg_id == 2061584302089,
    *node_label[reply_id, "comment"],

    *edge[e2, reply_id, replyAuthor],
    *edge_label[e2, "hasCreator"],
    *edge[e3, msg_id, messageAuthor],
    *edge_label[e3, "hasCreator"],

    # different authors + friends = true
    (replyAuthor != messageAuthor),
    knows_pair[replyAuthor, messageAuthor],
    knows_flag = true

replies[reply_id, replyAuthor, messageAuthor, knows_flag] :=
    *edge[e1, reply_id, msg_id],
    *edge_label[e1, "replyOf"],
    msg_id == 2061584302089,
    *node_label[reply_id, "comment"],

    *edge[e2, reply_id, replyAuthor],
    *edge_label[e2, "hasCreator"],
    *edge[e3, msg_id, messageAuthor],
    *edge_label[e3, "hasCreator"],

    # different authors + no friendship = false
    (replyAuthor != messageAuthor),
    not knows_pair[replyAuthor, messageAuthor],
    knows_flag = false

?[reply_id, replyAuthor, messageAuthor, knows_flag] :=
    replies[reply_id, replyAuthor, messageAuthor, knows_flag]


#Cypher

MATCH (origMsg)
WHERE origMsg.id = 2061584302089

MATCH (reply:Comment)-[:REPLY_OF]->(origMsg)


MATCH (replyAuthor:Person)<-[:HAS_CREATOR]-(reply)
MATCH (origAuthor:Person)<-[:HAS_CREATOR]-(origMsg)


OPTIONAL MATCH (replyAuthor)-[:KNOWS]-(origAuthor)

WITH reply, replyAuthor, origAuthor,
     CASE
         WHEN replyAuthor = origAuthor THEN false
         WHEN (replyAuthor)-[:KNOWS]-(origAuthor) THEN true
         ELSE false
     END AS knows

RETURN reply.id AS reply_id,
       replyAuthor.id AS replyAuthorId,
       origAuthor.id AS messageAuthorId,
       knows

IC1 : Transitive friends with a certain name
Given a start Person with ID $personId, find Persons with a given first name ($firstName) that the
start Person is connected to (excluding start Person) by at most 3 steps via the knows relationships.
Return Persons, including the distance (1..3), summaries of the Persons workplaces and places of
study.

#cozo

#BFS : profondeur 1
reach1[n_start, n1, dist] :=
    n_start=2199023256684,
    *edge[e,n_start, n1],
    *edge_label[e, 'knows'],
    dist=1

#BFS : profondeur 2
reach2[n_start, n2, dist] :=
    reach1[n_start, n1, 1],
    *edge[e, n1, n2],
    *edge_label[e, 'knows'],
    dist=2,
    n2 != n_start

#BFS : profondeur 3
reach3[n_start, n3, dist] :=
    reach2[n_start, n2, 2],
    *edge[e, n2, n3],
    *edge_label[e, 'knows'],
    dist=3,
    n3 != n_start

# Union des reachables
reachable[n_start, n, dist] :=
    reach1[n_start, n, dist]
  or reach2[n_start, n, dist]
  or reach3[n_start, n, dist]

# filter by given firstName
filtered[n, dist] :=
    reachable[n_start, n, dist],
    *node_prop[n, 'firstName', 'Boy']

# Récupérer les workplaces
workplace[n, company_loc] :=
    *edge[e, n, c],
    *edge_label[e, 'workAt'],
    *edge[e2, c, p],
    *edge_label[e2, 'isLocatedIn'],
    *node_prop[p, 'name', company_loc]

# Récupérer les places of study
studyplace[n, school_loc] :=
   *edge[e, n, s],
    *edge_label[e, 'studyAt'],
    *edge[e2, s, p],
    *edge_label[e2, 'isLocatedIn'],
    *node_prop[p, 'name', school_loc]

# Récupérer les coordonnées of a frieend
person_info[n, ln, br,  cr, gr, brw, ip, em, sp, city_name] := *node_prop[n, "lastName", ln], *node_prop[n, "locationIP", ip], *node_prop[n, "birthday", br], *node_prop[n, "creationDate", cr],*node_prop[n, "gender", gr],*node_prop[n, "browserUsed", brw],  *node_prop[n, "email", em], *node_prop[n, "speaks", sp], *edge_label[e, "isLocatedIn"], *edge[e,n,n2],*node_label[n2, "place"], *node_prop[n2, "name", city_name]

# Résultat final
?[person_id, dist, ln, br,  cr, gr, brw, ip,  city_name, companies, universities, em, sp] :=
    filtered[person_id, dist],
    person_info[person_id, ln, br,  cr, gr, brw, ip, em, sp, city_name],
    workplace[person_id, companies],
    studyplace[person_id, universities]



#Cypher
#fs01 2199023256684 "Boy"
#sf03
#sf1
// Parameters 
WITH 2199023256684 AS personId, "Boy" AS firstName

// k-length variable path
MATCH (start:Person {id: personId})
MATCH path = (start)-[:KNOWS*1..3]->(other:Person)
WHERE start <> other AND other.firstName = firstName

// Distance = length of the path
WITH DISTINCT other, length(path) AS dist

// Person info
OPTIONAL MATCH (other)-[:IS_LOCATED_IN]->(city:Place)
WITH other, dist, city

// Workplaces
OPTIONAL MATCH (other)-[:WORK_AT]->(company)-[:IS_LOCATED_IN]->(companyPlace:Place)
WITH other, dist, city,
     collect(DISTINCT companyPlace.name) AS companies

// Study places
OPTIONAL MATCH (other)-[:STUDY_AT]->(school)-[:IS_LOCATED_IN]->(schoolPlace:Place)
WITH other, dist, city, companies,
     collect(DISTINCT schoolPlace.name) AS universities

RETURN
    other.id AS person_id,
    dist,
    other.lastName AS ln,
    other.birthday AS br,
    other.creationDate AS cr,
    other.gender AS gr,
    other.browserUsed AS brw,
    other.locationIP AS ip,
    other.email AS em,
    other.speaks AS sp,
    city.name AS city_name,
    companies,
    universities

IC3 : 

Given a start Person with ID $personId, find Persons that are their friends and friends of friends
(excluding the start Person) that have made Posts / Comments in both of the given Countries (named
$countryXName and $countryYName), within [$startDate, $startDate + $durationDays) (closedopen
interval). Only Persons that are foreign to these Countries are considered, that is Persons
whose location Country is neither named $countryXName nor $countryYName.

#cozo
# path Depth 1 : direct friends of person_id 
reach1[person_id, f1] := person_id=1129,
    *edge[e, person_id, f1],
    *edge_label[e, "knows"],
    f1 != person_id

# pathh Depth 2 : friends-of-friends FOF
reach2[person_id, f2] :=
person_id = 1129,
    reach1[person_id, x],
    *edge[e, x, f2],
    *edge_label[e, "knows"],
    f2 != person_id

# Union of friends n FOF 
friends[p] :=
    reach1[person_id, p]
  or reach2[person_id, p]


# Find the country where a Person p lives
person_country[p, country_name] :=
    *edge[e1, p, city],
    *edge_label[e1, "isLocatedIn"],
    *edge[e2, city, country],
    *edge_label[e2, "isPartOf"],
    *node_prop[country, "name", country_name]


# Filter persons who are NOT living in country X or Y(foreigners)
foreign_person[p] :=
country_x = "China",
country_y = "France",
    friends[p],
    person_country[p, ctry],
    ctry != country_x,
    ctry != country_y

# Messages (posts or comments) created by a person respecting a certain ceationDate
message[p, m] :=
start_date =1341100800000,
duration_days =2,
end_date = start_date + duration_days * 86400000,
    *edge[e, m, p],
    *edge_label[e, "hasCreator"],
    *node_prop[m, "creationDate", date],
    date >= start_date,
    date < end_date,
    (
        *node_label[m, "post"]
      or *node_label[m, "comment"]
    )

# Country where a message was created
message_country[m, ctry] :=
    *edge[e1, m, place],
    *edge_label[e1, "isLocatedIn"],
    *edge[e2, place, country],
    *edge_label[e2, "isPartOf"],
    *node_prop[country, "name", ctry]

# Count messages in Country X
msg_count_x[p, count(m)] :=
    country_x = "China",
    foreign_person[p],
    message[p, m],
    message_country[m, ctry],
    ctry = country_x
    
# Count messages in Country Y
msg_count_y[p, count(m)] :=
country_y = "France",
    foreign_person[p],
    message[p, m],
    message_country[m, ctry],
    ctry = country_y
   

# Count persons who posted in BOTH countries
both_counts[p, xcnt, ycnt, cnt] :=
    msg_count_x[p, xcnt],
    msg_count_y[p, ycnt],
    cnt=xcnt+ycnt


# Person identity (firstName, lastName)
person_info[p, fn, ln] :=
    *node_prop[p, "firstName", fn],
    *node_prop[p, "lastName", ln]

# Final result
?[p, fn, ln, xcnt, ycnt, total] :=
    both_counts[p, xcnt, ycnt, total],
    person_info[p, fn, ln]

#Cypher
#requete pour trouver les Parameters

MATCH (op:Person)-[:IS_LOCATED_IN]->(homeCity:Place)-[:IS_PART_OF*0..]->(homeCountry:Place)
WHERE homeCountry.type = 'country'
WITH op, homeCountry

// messages créés par op (Post ou Comment)
MATCH (op)<-[:HAS_CREATOR]-(m)
WHERE m:Post OR m:Comment

// pays du message
MATCH (m)-[:IS_LOCATED_IN]->(msgCity:Place)-[:IS_PART_OF*0..]->(msgCountry:Place)
WHERE msgCountry.type = 'country'
  AND msgCountry <> homeCountry 
  AND msgCountry.name <> "Israel"        

WITH op, homeCountry, msgCountry.name AS countryName,
     count(m) AS msgCount, min(m.creationDate) AS minDate, max(m.creationDate) AS maxDate
ORDER BY msgCount DESC

// collecter les pays, on garde les 2 premiers
WITH op, homeCountry, collect({country: countryName, cnt: msgCount, minD: minDate, maxD: maxDate}) AS byCountry
WHERE size(byCountry) >= 2

WITH op, homeCountry, byCountry[0] AS c1, byCountry[1] AS c2

// trouver un ami ou ami-d’ami
MATCH (p1:Person)-[:KNOWS*1..2]-(op)
WHERE p1 <> op

RETURN
  p1.id                       AS personId,
  op.id                       AS otherPersonId,
  op.firstName                AS firstName,
  op.lastName                 AS lastName,
  homeCountry.name            AS homeCountry,
  c1.country                  AS countryX,
  c2.country                  AS countryY,
  c1.minD                     AS minDateX,
  c1.maxD                     AS maxDateX,
  c2.minD                     AS minDateY,
  c2.maxD                     AS maxDateY
  

LIMIT 20;

#requete IC3
// PARAMETERS
WITH 
 2199023256684 AS personId,
 "Bosnia_and_Herzegovina"	 AS countryX,
 "Northern_Ireland" AS countryY,
 1221035678258 AS startDate,
 2 As DurationDays,
 (1221035678258 + 2*86400000) AS endDate


// Friends & friends-of-friends

MATCH (start:Person {id: personId})
MATCH fof = (start)-[:KNOWS*1..2]->(p:Person)
WHERE p <> start
WITH DISTINCT p, countryX, countryY, startDate, endDate

// Person must NOT live in country X or Y

MATCH (p)-[:IS_LOCATED_IN]->(:Place)-[:IS_PART_OF]->(pcountry:Place)
WHERE pcountry.name <> countryX AND pcountry.name <> countryY
WITH DISTINCT p, countryX, countryY, startDate, endDate


// Messages created in the time interval

OPTIONAL MATCH (p)<-[:HAS_CREATOR]-(m)
WHERE (m:Post OR m:Comment)
  AND m.creationDate >= startDate
  AND m.creationDate < endDate

// Message country
OPTIONAL MATCH (m)-[:IS_LOCATED_IN]->(mcountry:Place)
WITH p, countryX, countryY,
     collect(mcountry.name) AS msgCountries

// Count messages in X and Y

WITH 
   p,
   countryX,
   countryY,
   size([x IN msgCountries WHERE x = countryX]) AS xCount,
   size([y IN msgCountries WHERE y = countryY]) AS yCount
WHERE xCount > 0 AND yCount > 0


// Person info

RETURN 
    p.id AS personId,
    p.firstName AS firstName,
    p.lastName AS lastName,
    xCount,
    yCount,
    xCount + yCount AS totalCount

IC 13 : Single shortest path
Given two persons with IDs $person1Id and $person2Id, find the shortest path between these two persons in the subgraph induced by the knows edges. Return the length of this path:

−1 : no path found

0 : start person = end person

> 0 : path found (start person ≠ end person)

#cozo
#sf03 933 32985348834886
#sf1 3528 8796093026629

# Define the subgraph of KNOWS edges
friendEdges[from, to] := *edge[e, from, to], *edge_label[e, "knows"]

# Input nodes (single-row relations)
starting[start_idx] <- [[933]]
goal[goal_idx]     <- [[32985348834886]]

# Compute shortest path (BFS) between person1 and person2
paths[start, goal, path] <~ ShortestPathBFS(friendEdges[from, to],
                                            starting[start_idx],
                                            goal[goal_idx])

# Output rules:
? [len] := starting[start_idx], goal[goal_idx], start_idx == goal_idx, len = 0
? [len] := starting[start_idx], goal[goal_idx], paths[start_idx, goal_idx, path], len = length(path)
? [len] := starting[start_idx], goal[goal_idx], not paths[start_idx, goal_idx, _], len = -1

#Cypher
MATCH path = shortestPath(
  (p1:Person {id: 933})-[:KNOWS*..]->(p2:Person {id: 32985348834483})
)
RETURN 
  CASE 
    WHEN p1.id= p2.id THEN 0
    WHEN path IS NULL THEN -1
    ELSE length(path)
  END AS pathLength;

IC 14 : Trusted connection paths 
Given two persons with IDs $person1Id and $person2Id, find all (unweighted) shortest paths between these two persons in the subgraph induced by the knows relationship.

Then, for each path, calculate a weight.
The nodes in the path are Persons, and the weight of a path is the sum of weights between every pair of consecutive Person nodes in the path.

The weight for a pair of Persons is calculated based on their interactions:

Every direct reply (by one of the Persons) to a Post (by the other Person) is 1.0.

Every direct reply (by one of the Persons) to a Comment (by the other Person) is 0.5.

Note that interactions are counted both ways.
For example, if Alice writes 2 Post replies and 1 Comment reply to Bob, while Bob writes 3 Post replies and 4 Comment replies to Alice, their interaction score is:
2 × 1.0 + 1 × 0.5 + 3 × 1.0 + 4 × 0.5 = 7.5.

Return all the paths with shortest length and their weights.
Do not return any rows if there is no path between the two Persons.

#COZO

# Definir le sous-graphe  des relations KNOWS
knowsEdges[from, to] :=
    *edge[e, from, to],
    *edge_label[e, "knows"]

# Définir les IDs de départ et d'arrivée
start_person[] <- [[3528]]
end_person[]   <- [[8796093026629]]

# Chercher les  plus courts chemins 
paths[start, end, cost, path] <~ 
    KShortestPathYen(knowsEdges[from, to], start_person[], end_person[], k: 3, undirected: false)

# Générer les paires de noeuds consécutifs pour chaque chemin
pairs[path, a, b] :=
    paths[start, end, cost, path],
    w in windows(path, 2),
    a = get(w, 0),
    b = get(w, 1)

# Nombre de réponses (commentaires) d'une personne A à un post de B
postCount[a, b, count(c)] :=
    *node_label[c, "comment"],
    *edge[e1, c, a],
    *edge_label[e1, "hasCreator"],
    *edge[e2, c, p],
    *edge_label[e2, "replyOf"],
    *node_label[p, "post"],
    *edge[e3, p, b],
    *edge_label[e3, "hasCreator"]

# Nombre de réponses (commentaires) d'une personne A à un commentaire de B
commentCount[a, b, count(c)] :=
    *node_label[c, "comment"],
    *edge[e1, c, a],
    *edge_label[e1, "hasCreator"],
    *edge[e2, c, c2],
    *edge_label[e2, "replyOf"],
    *node_label[c2, "comment"],
    *edge[e3, c2, b],
    *edge_label[e3, "hasCreator"]

# Calcul du poids entre deux personnes dans les deux sens A vers B et B vers A
pairWeight[a, b, weight] :=
    postCount[a, b, p1],
    commentCount[a, b, c1],
    postCount[b, a, p2],
    commentCount[b, a, c2],
    weight = p1 * 1.0 + c1 * 0.5 + p2 * 1.0 + c2 * 0.5

# Somme du poids total par chemin 
pathWeight[path, sum(w)] :=
    pairs[path, a, b],
    pairWeight[a, b, w]

# Résultat final : chaque chemin, sa longueur et son poids total
?[path, len, totalWeight] :=
    paths[start, end, cost, path],
    pathWeight[path, totalWeight],
     len= length(path)


#Cypher

// find two ids of person in 3-length knows path
MATCH (p1:Person)-[:KNOWS*3]->(p2:Person)
RETURN DISTINCT p1.id, p2.id
limit 1;
sf01 933 32985348834483
sf03 933 32985348834886
sf1 3528 8796093026629


#Cypher

MATCH p = allShortestPaths((p1:Person {id: 933})-[:KNOWS*]->(p2:Person {id: 32985348834483}))
WITH p, nodes(p) AS persons
UNWIND range(0, size(persons)-2) AS i
WITH p, persons[i] AS a, persons[i+1] AS b


OPTIONAL MATCH (a)<-[:HAS_CREATOR]-(reply1:Comment)-[:REPLY_OF]->(msg1:Post)-[:HAS_CREATOR]->(b)
WITH p, a, b, COUNT(DISTINCT reply1) AS repliesToPost
OPTIONAL MATCH (a)<-[:HAS_CREATOR]-(reply2:Comment)-[:REPLY_OF]->(msg2:Comment)-[:HAS_CREATOR]->(b)

WITH p, a, b, repliesToPost, COUNT(DISTINCT reply2) AS repliesToComment

WITH p, a, b, (repliesToPost * 1.0 + repliesToComment * 0.5) AS ab_weight


OPTIONAL MATCH (b)<-[:HAS_CREATOR]-(reply3:Comment)-[:REPLY_OF]->(msg3:Post)-[:HAS_CREATOR]->(a)
WITH p, a, b, ab_weight, COUNT(DISTINCT reply3) AS repliesToPostRev
OPTIONAL MATCH (b)<-[:HAS_CREATOR]-(reply4:Comment)-[:REPLY_OF]->(msg4:Comment)-[:HAS_CREATOR]->(a)
WITH p, a, b, ab_weight, repliesToPostRev, COUNT(DISTINCT reply4) AS repliesToCommentRev


WITH p, (ab_weight + repliesToPostRev*1.0 + repliesToCommentRev*0.5) AS pair_weight


WITH p, SUM(pair_weight) AS total_weight
RETURN p AS path,length(p) AS len, total_weight






